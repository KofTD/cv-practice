# Практическая работа №1. Обработка изображений с использованием библиотеки OpenCV ##

## 1) `resize_image(img, scale)`

Предназначен для изменения размера изображения. В реализации используется метод ближайших соседей 
Принцип работы:
    - Создаётся пустое изображение нового размера `(int(h*scale), int(w*scale))`.
    - Для каждого пикселя нового изображения вычисляются координаты соответствующего пикселя исходного изображения через деление на коэффициент масштабирования.
    - Значение цвета исходного пикселя присваивается новому.

Параметры:

`img` - передаваемое изображение

`scale` - коэффициент масштабирования изображения

 ## 2) `sepia(img, k)`

Предназначен для наложения сепии.    

Принцип работы:
- Для каждого пикселя изменяются каналы по формулам:
  - `R = R + 2*k`
  - `G = G + 0.5*k`
  - `B = B - k`
- Используется `np.clip`, чтобы значения не выходили за пределы [0,255].
    
Параметры:

`img` - передаваемое изображение

`k` - насыщенность сепии


## 3) `def vinetka(img,k,radius,center)`

Предназначен для затемнения краёв изображения.
Принцип работы:
- Для каждого пикселя изображения рассчитывается его евклидово расстояние до центра виньетки, формируя массив distances.
- Рассчитанные расстояния нормируются, чтобы их значения находились в диапазоне [0, 1].
- Для пикселей, расстояние до центра которых превышает заданный радиус (принадлежащий отрезку [0, 1]), вычисляется коэффициент затухания по формуле: `coeffs[mask] = 1-k*(norm_distanses[mask]-radius)/(1-radius)`
    - Здесь norm_distances[mask] - radius определяет начало затемнения от заданного радиуса (светлая центральная область).
    - Деление на 1 - radius обеспечивает плавное усиление затемнения к краям изображения.
    - Параметр k регулирует интенсивность затемнения.
 - Каждый пиксель изображения умножается на соответствующий коэффициент затухания coeff, что приводит к затемнению краев с сохранением яркости в центре.

Параметры:

`img` - передаваемое изображение

`k` - интенсивность виньетки

`raduis` - радиус окружности, вне которой начинается виньетирование

`center` - центр виньентирования

## 4) `pixelize(img, oblast, k)`

Предназначен для пикселизации области.

Принцип работы:
- Область изменяется на несколько пикселей, чтобы стать кратной значению `k`.
- Изображение сжимается в `k` раз и затем увеличивается во столько же, с помощью функции `resize_image()`, там самым заменяя пиксели в ячейках размера `k x k` одним значением из ячейки.
    
Параметры:

`img` - передаваемое изображение

`oblast` - область пикселизации

`k` - степень пикселизации 

## 5) `rect_frame(img, width, color)`

Предназначен для создания прямоугольной рамки вокруг изображения.
Принцип работы:
- Создаётся новое изображение увеличенного размера с фоновым цветом.
- Исходное изображение вставляется внутрь.  

Параметры:

`img` - передаваемое изображение

`width` - ширина рамки

`color` - цвет рамки

## 6) `def frame(img, frame, thickness)`

Предназначен для создания рамки произвольной формы.
Принцип работы:
- Из шаблона рамки вырезаются углы и 4 стороны.
- Стороны масштабируются под размер изображения с помощью функции `resize_1d(img, heigh: bool, new)` и накладываются на исходное изображение

Параметры:

`img` - передаваемое изображение

`frame` - изображение с рамки на черном фоне

`thickness` - ширина рамки

## 7) `bliki(img,texture,k)`

Предназначен для наложения эффекта блика объектива.    
Принцип работы:
- Текстура бликов увеличивается так, чтобы одна из ее сторон совпадала с размером соответствующей стороны исходного изображения
- После увеличения текстура обрезается под размер изображения и складывается с изображением. Возможно изменение интенсивности блика с помощью параметра `k`

Параметры:

`img` - передаваемое изображение

`texture` - изображение с текстурой блика

`k` - интенсивность блика

## 8) `def watercolor(img, texture,k)`
Предназначен для наложения эффекта акварельной бумаги.    
Принцип работы:
- Текстура бумаги увеличивается так, чтобы одна из ее сторон совпадала с размером соответствующей стороны исходного изображения
- После увеличения текстура обрезается под размер изображения и взвешенно складывается с изображением по формуле `k*img + (1-k)*cropped_texture`. Вес определяется параметром `k`

Параметры:

`img` - передаваемое изображение

`texture` - изображение с акварельной текстурой

`k` - интенсивность смешивания
